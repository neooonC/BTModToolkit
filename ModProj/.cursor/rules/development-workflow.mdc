---
title: "BattleTalent Mod Development Workflow"
description: "Complete workflow guide for creating, testing, and deploying BattleTalent VR mods"
type: "workflow"
globs: ["Assets/Build/**/*", "Assets/Mods/**/*", "**/*.prefab", "**/*.asset", "Assets/Toolkit/**/*", "Assets/Editor/**/*"]
alwaysApply: true
tags: ["workflow", "development", "testing", "deployment", "mod-creation"]
---

# BattleTalent Mod Development Workflow

## Project Setup and Initialization

### 1. New Mod Creation Process
```bash
# Create mod directory structure following BattleTalent conventions
Assets/Build/{ModName}/
├── Config/              # .asset configuration files
│   ├── ItemInfoConfig.asset
│   ├── AddressableGroupConfig.asset
│   └── {ModName}Config.asset
├── Script/              # Lua scripts (.txt extension)
│   ├── {ModName}Script.txt
│   ├── {ModName}Controller.txt
│   └── {ModName}Utils.txt
├── Weapon/              # Weapon prefabs and components
│   ├── {ModName}_Main.prefab
│   ├── {ModName}_Variant1.prefab
│   └── Materials/
├── Effect/              # Particle effects and materials
│   ├── {EffectName}.prefab
│   └── Materials/
├── Audio/               # Sound effects and audio clips
│   ├── SFX/
│   └── Music/
└── Resources/           # Additional resources
    ├── Textures/
    ├── Models/
    └── Animations/
```

### 2. File Naming Standards
- **Mod Directories**: `{ModName}` (PascalCase, e.g., `MagicBow`, `SwordIce`)
- **Script Files**: `{ComponentName}Script.txt` (e.g., `MagicBowScript.txt`)
- **Config Files**: `{ModName}Config.asset` 
- **Prefabs**: `{ModName}_{Variant}.prefab` (e.g., `MagicBow_Fire.prefab`)
- **Materials**: `{ModName}_{Type}Mat.mat` (e.g., `SwordIce_BladeMat.mat`)
│   └── ModMetadata.asset
├── Script/              # .txt Lua scripts
│   ├── {ModName}Script.txt
│   ├── {ModName}Controller.txt
│   └── Utils/
├── Weapon/              # .prefab weapon files
│   ├── {WeaponName}.prefab
│   └── Variants/
├── Effect/              # .prefab particle effects
│   ├── Visual/
│   ├── Audio/
│   └── Physics/
├── Icon/               # .png icon files
│   ├── {ModName}_Icon.png
│   ├── {ModName}_Preview.png
│   └── UI/
├── Materials/          # .mat material files
├── Textures/          # .png, .jpg texture files
├── Audio/             # .wav, .mp3 audio files
├── Documentation/     # .md documentation files
│   ├── README.md
│   ├── API.md
│   └── CHANGELOG.md
└── Tests/             # Unit test files
    ├── {ModName}Tests.cs
    └── Integration/
```

### 2. Mod Configuration Setup
```csharp
// ModMetadata.asset structure
[CreateAssetMenu(fileName = "ModMetadata", menuName = "BattleTalent/Mod Metadata")]
public class ModMetadata : ScriptableObject
{
    [Header("Basic Information")]
    public string modName;
    public string displayName;
    public string author;
    public string version;
    public string description;
    
    [Header("Compatibility")]
    public string gameVersion;
    public string[] requiredMods;
    public string[] optionalMods;
    public Platform[] supportedPlatforms;
    
    [Header("Content")]
    public ModCategory category;
    public string[] tags;
    public Texture2D icon;
    public Texture2D[] screenshots;
    
    [Header("Technical")]
    public bool requiresNetworking;
    public bool hasLuaScripts;
    public bool hasCSharpScripts;
    public string[] addressableGroups;
}

// Auto-generate addressable configuration
[MenuItem("BattleTalent/Setup New Mod")]
public static void SetupNewMod()
{
    var modName = EditorUtility.OpenFilePanel("Mod Name", "", "");
    if (string.IsNullOrEmpty(modName)) return;
    
    CreateModDirectoryStructure(modName);
    GenerateModMetadata(modName);
    SetupAddressableGroups(modName);
    CreateDefaultScripts(modName);
}
```

### 3. Addressable Group Configuration
```csharp
public class AddressableGroupSetup
{
    public static void CreateModGroups(string modName)
    {
        var settings = AddressableAssetSettingsDefaultObject.Settings;
        
        // Main mod content group
        var mainGroup = settings.CreateGroup($"Mod_{modName}_Main", false, false, true, 
            null, typeof(ContentUpdateGroupSchema), typeof(BundledAssetGroupSchema));
        
        // Platform-specific groups
        var pcGroup = settings.CreateGroup($"Mod_{modName}_PC", false, false, true,
            null, typeof(ContentUpdateGroupSchema), typeof(BundledAssetGroupSchema));
            
        var androidGroup = settings.CreateGroup($"Mod_{modName}_Android", false, false, true,
            null, typeof(ContentUpdateGroupSchema), typeof(BundledAssetGroupSchema));
        
        // Remote content group for optional downloads
        var remoteGroup = settings.CreateGroup($"Mod_{modName}_Remote", false, false, true,
            null, typeof(ContentUpdateGroupSchema), typeof(BundledAssetGroupSchema));
        
        // Configure group settings
        ConfigureGroupForPlatform(pcGroup, BuildTarget.StandaloneWindows64);
        ConfigureGroupForPlatform(androidGroup, BuildTarget.Android);
        ConfigureRemoteGroup(remoteGroup);
    }
}
```

## Development Phases

### Phase 1: Core Functionality Development
```csharp
// Development checklist template
public class ModDevelopmentChecklist
{
    [System.Serializable]
    public struct DevelopmentPhase
    {
        public string phaseName;
        public string[] requirements;
        public string[] deliverables;
        public bool isCompleted;
    }
    
    public DevelopmentPhase[] phases = new DevelopmentPhase[]
    {
        new DevelopmentPhase
        {
            phaseName = "Core Functionality",
            requirements = new[]
            {
                "Basic mod structure created",
                "Main script implemented",
                "Core gameplay mechanics working",
                "Basic VR interactions functional"
            }
        },
        new DevelopmentPhase
        {
            phaseName = "Asset Integration",
            requirements = new[]
            {
                "All visual assets imported",
                "Audio assets configured",
                "Material setup complete",
                "Prefabs assembled and tested"
            }
        },
        new DevelopmentPhase
        {
            phaseName = "Polish and Optimization",
            requirements = new[]
            {
                "Performance optimization completed",
                "Visual effects polished",
                "Audio mixing finalized",
                "User experience refined"
            }
        }
    };
}
```

### Phase 2: Integration and Testing
```csharp
// Automated testing framework for mods
public class ModTestSuite : MonoBehaviour
{
    [Header("Test Configuration")]
    public ModMetadata modToTest;
    public TestEnvironment testEnvironment;
    
    [Header("Test Results")]
    public List<TestResult> testResults = new List<TestResult>();
    
    public async Task RunAllTests()
    {
        testResults.Clear();
        
        // Basic functionality tests
        await RunBasicFunctionalityTests();
        
        // VR interaction tests
        await RunVRInteractionTests();
        
        // Performance tests
        await RunPerformanceTests();
        
        // Networking tests (if applicable)
        if (modToTest.requiresNetworking)
            await RunNetworkingTests();
        
        // Generate test report
        GenerateTestReport();
    }
    
    private async Task RunBasicFunctionalityTests()
    {
        var tests = new[]
        {
            TestModLoading(),
            TestAssetLoading(),
            TestScriptExecution(),
            TestResourceCleanup()
        };
        
        var results = await Task.WhenAll(tests);
        testResults.AddRange(results);
    }
}
```

### Phase 3: Platform Testing
```csharp
// Cross-platform testing utilities
public class CrossPlatformTester
{
    public static async Task<TestResult> TestPCCompatibility(ModMetadata mod)
    {
        var result = new TestResult { testName = "PC Compatibility" };
        
        try
        {
            // Test addressable loading on PC
            var pcAssets = await LoadPlatformAssets("PC");
            result.passed = pcAssets.All(asset => asset != null);
            
            // Test VR controller support
            var vrControllerTest = TestVRControllerSupport();
            result.passed &= vrControllerTest;
            
            // Test performance on PC specs
            var performanceTest = await TestPCPerformance();
            result.passed &= performanceTest;
            
        }
        catch (Exception ex)
        {
            result.passed = false;
            result.errorMessage = ex.Message;
        }
        
        return result;
    }
    
    public static async Task<TestResult> TestAndroidCompatibility(ModMetadata mod)
    {
        var result = new TestResult { testName = "Android Compatibility" };
        
        try
        {
            // Test Quest-specific features
            var questFeatures = TestQuestSpecificFeatures();
            result.passed = questFeatures;
            
            // Test mobile performance constraints
            var mobilePerformance = await TestMobilePerformance();
            result.passed &= mobilePerformance;
            
            // Test hand tracking compatibility
            var handTracking = TestHandTrackingCompat();
            result.passed &= handTracking;
            
        }
        catch (Exception ex)
        {
            result.passed = false;
            result.errorMessage = ex.Message;
        }
        
        return result;
    }
}
```

## Testing Workflows

### Unit Testing Framework
```csharp
// Mod-specific unit testing
[TestFixture]
public class ModUnitTests
{
    private GameObject modPrefab;
    private ModController modController;
    
    [SetUp]
    public void Setup()
    {
        // Load mod assets for testing
        modPrefab = Resources.Load<GameObject>("TestMod");
        var modInstance = Object.Instantiate(modPrefab);
        modController = modInstance.GetComponent<ModController>();
    }
    
    [Test]
    public void ModInitializesCorrectly()
    {
        Assert.IsNotNull(modController, "Mod controller should be present");
        Assert.IsTrue(modController.IsInitialized, "Mod should initialize successfully");
    }
    
    [Test]
    public void ModHandlesVRInteractionsProperly()
    {
        // Simulate VR controller input
        var mockController = new MockVRController();
        mockController.SimulateGrab();
        
        bool grabbable = modController.CanBeGrabbed();
        Assert.IsTrue(grabbable, "Mod should be grabbable in VR");
    }
    
    [UnityTest]
    public IEnumerator ModPerformsWithinFrameRate()
    {
        float startTime = Time.realtimeSinceStartup;
        
        // Run mod for several frames
        for (int i = 0; i < 100; i++)
        {
            yield return null;
        }
        
        float endTime = Time.realtimeSinceStartup;
        float averageFrameTime = (endTime - startTime) / 100f;
        
        Assert.Less(averageFrameTime, 0.016f, "Mod should maintain 60fps performance");
    }
}
```

### Integration Testing
```csharp
// Integration with BattleTalent systems
public class ModIntegrationTests : MonoBehaviour
{
    [Test]
    public async Task TestModLoadsInGameEnvironment()
    {
        // Load mod in actual game context
        var modLoader = FindObjectOfType<ModLoader>();
        var loadResult = await modLoader.LoadModAsync("TestMod");
        
        Assert.IsTrue(loadResult.success, $"Mod loading failed: {loadResult.error}");
        Assert.IsNotNull(loadResult.modInstance, "Mod instance should be created");
    }
    
    [Test]
    public void TestModNetworkingSynchronization()
    {
        // Test multiplayer synchronization
        var networkMod = FindObjectOfType<NetworkedModComponent>();
        
        // Simulate network state change
        networkMod.SimulateNetworkUpdate();
        
        // Verify all clients receive update
        var clients = NetworkServer.connections;
        foreach (var client in clients)
        {
            Assert.IsTrue(client.HasReceivedUpdate(), "All clients should receive mod updates");
        }
    }
}
```

### Performance Testing
```csharp
public class ModPerformanceTester : MonoBehaviour
{
    [Header("Performance Thresholds")]
    public float maxFrameTime = 0.016f; // 60 FPS
    public int maxMemoryUsageMB = 100;
    public float maxLoadTime = 5.0f;
    
    public async Task<PerformanceReport> RunPerformanceTests()
    {
        var report = new PerformanceReport();
        
        // Test loading performance
        report.loadTime = await MeasureLoadTime();
        
        // Test runtime performance
        report.averageFrameTime = await MeasureFrameTime();
        
        // Test memory usage
        report.memoryUsage = MeasureMemoryUsage();
        
        // Test VR-specific performance
        report.vrPerformance = await MeasureVRPerformance();
        
        return report;
    }
    
    private async Task<float> MeasureLoadTime()
    {
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        
        // Load mod and all its assets
        await LoadModCompletely();
        
        stopwatch.Stop();
        return stopwatch.ElapsedMilliseconds / 1000f;
    }
}
```

## Build and Deployment

### Automated Build Pipeline
```csharp
public class ModBuildPipeline
{
    [MenuItem("BattleTalent/Build Mod")]
    public static void BuildCurrentMod()
    {
        var activeMod = GetActiveModFromSelection();
        if (activeMod == null)
        {
            EditorUtility.DisplayDialog("Error", "No mod selected", "OK");
            return;
        }
        
        BuildMod(activeMod);
    }
    
    public static async Task BuildMod(ModMetadata mod)
    {
        Debug.Log($"Starting build for mod: {mod.modName}");
        
        try
        {
            // Validate mod configuration
            await ValidateModConfiguration(mod);
            
            // Build addressable content
            await BuildAddressableContent(mod);
            
            // Generate mod manifest
            GenerateModManifest(mod);
            
            // Create distribution package
            CreateDistributionPackage(mod);
            
            // Run post-build validation
            await ValidateBuildOutput(mod);
            
            Debug.Log($"Build completed successfully for {mod.modName}");
        }
        catch (Exception ex)
        {
            Debug.LogError($"Build failed for {mod.modName}: {ex.Message}");
            throw;
        }
    }
    
    private static async Task BuildAddressableContent(ModMetadata mod)
    {
        // Build for PC
        AddressableAssetSettings.BuildPlayerContent();
        
        // Build for Android
        EditorUserBuildSettings.selectedBuildTargetGroup = BuildTargetGroup.Android;
        AddressableAssetSettings.BuildPlayerContent();
        
        // Reset to original platform
        EditorUserBuildSettings.selectedBuildTargetGroup = BuildTargetGroup.Standalone;
    }
}
```

### Distribution and Packaging
```csharp
public class ModDistributor
{
    public static void CreateDistributionPackage(ModMetadata mod)
    {
        var packagePath = $"Builds/{mod.modName}_v{mod.version}";
        Directory.CreateDirectory(packagePath);
        
        // Copy built addressable content
        CopyAddressableContent(mod, packagePath);
        
        // Copy mod manifest
        CopyModManifest(mod, packagePath);
        
        // Copy documentation
        CopyDocumentation(mod, packagePath);
        
        // Create platform-specific packages
        CreatePlatformPackages(mod, packagePath);
        
        // Generate checksums for integrity verification
        GenerateChecksums(packagePath);
        
        Debug.Log($"Distribution package created at: {packagePath}");
    }
    
    private static void CreatePlatformPackages(ModMetadata mod, string basePath)
    {
        // PC package
        var pcPath = Path.Combine(basePath, "PC");
        Directory.CreateDirectory(pcPath);
        CopyPlatformSpecificAssets(mod, "PC", pcPath);
        
        // Android package
        var androidPath = Path.Combine(basePath, "Android");
        Directory.CreateDirectory(androidPath);
        CopyPlatformSpecificAssets(mod, "Android", androidPath);
    }
}
```

## Quality Assurance

### Code Review Checklist
```csharp
// Automated code quality checks
public class ModQualityChecker
{
    public static QualityReport CheckModQuality(ModMetadata mod)
    {
        var report = new QualityReport();
        
        // Check for common issues
        report.issues.AddRange(CheckForCommonIssues(mod));
        
        // Validate asset references
        report.issues.AddRange(ValidateAssetReferences(mod));
        
        // Check performance guidelines
        report.issues.AddRange(CheckPerformanceGuidelines(mod));
        
        // Validate VR compatibility
        report.issues.AddRange(CheckVRCompatibility(mod));
        
        // Check networking compliance
        if (mod.requiresNetworking)
            report.issues.AddRange(CheckNetworkingCompliance(mod));
        
        return report;
    }
}
```

### Documentation Standards
```markdown
# Mod Documentation Template

## Mod Name: {ModName}
**Version:** {Version}
**Author:** {Author}
**Compatible Game Version:** {GameVersion}

### Description
[Detailed description of what the mod does]

### Features
- Feature 1
- Feature 2
- Feature 3

### Installation
1. Download the mod package
2. Extract to BattleTalent/Mods/ directory
3. Launch the game
4. Enable the mod in the mod manager

### Configuration
[Describe any configuration options]

### Known Issues
[List any known issues or limitations]

### Changelog
#### Version {Version}
- Change 1
- Change 2

### Support
[Contact information or support channels]
```

## Troubleshooting and Debugging

### Common Issues and Solutions
```csharp
public class ModTroubleshooter
{
    private static readonly Dictionary<string, string> CommonIssues = new()
    {
        {"AssetNotFound", "Check addressable asset addresses and group configuration"},
        {"ScriptError", "Verify Lua script syntax and required dependencies"},
        {"PerformanceIssue", "Review Update() methods and consider object pooling"},
        {"NetworkDesync", "Ensure proper use of SyncVars and network authority"},
        {"VRInteractionFail", "Check XR interaction components and collider setup"}
    };
    
    public static void DiagnoseIssue(string issueType)
    {
        if (CommonIssues.TryGetValue(issueType, out var solution))
        {
            Debug.Log($"Issue: {issueType}\nSolution: {solution}");
        }
        else
        {
            Debug.Log("Unknown issue. Please check the documentation or contact support.");
        }
    }
}
```
1. Test mod in single-player first
2. Verify networking synchronization
3. Test with multiple clients (PC and Quest)
4. Check for network performance impact

## Deployment Process

### Local Development
1. Assets organized in addressable groups
2. Test with Unity editor play mode
3. Use ModImporter for quick iteration

### Build Process
1. Generate platform-specific builds (Windows/Android)
2. Output to `Assets/Mods/ModProj/` directory
3. Verify all dependencies are included
4. Test loading in actual game environment

### Quest Deployment
1. Use ADB tools for Quest device deployment
2. Test VR interactions and performance
3. Verify cross-platform multiplayer compatibility
4. Monitor Quest-specific performance metrics

## Quality Assurance Checklist

### Functionality
- [ ] All core features work as designed
- [ ] Proper error handling for edge cases
- [ ] Graceful handling of missing dependencies
- [ ] Multiplayer synchronization working correctly

### Performance
- [ ] No significant FPS impact
- [ ] Memory usage within acceptable limits
- [ ] Network bandwidth usage optimized
- [ ] Proper asset cleanup on mod unload

### Compatibility
- [ ] Works on both PC and Quest platforms
- [ ] Compatible with existing game systems
- [ ] No conflicts with other mods
- [ ] Proper version compatibility checking

### User Experience
- [ ] Intuitive VR interactions
- [ ] Clear visual and audio feedback
- [ ] Proper documentation and instructions
- [ ] Consistent with game's art style and theme
