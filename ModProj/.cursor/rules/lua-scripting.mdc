---
title: "Lua Scripting Guidelines for BattleTalent Mods"
description: "Comprehensive Lua scripting standards and patterns for creating BattleTalent VR mod content"
type: "patterns"
globs: ["Assets/Build/**/Script/**/*.txt", "**/*.lua", "Assets/Toolkit/**/*.lua"]
alwaysApply: false
tags: ["lua", "scripting", "game-logic", "performance", "api"]
---

# Lua Scripting Guidelines for BattleTalent Mods

## File Organization and Structure

### File Naming and Location
- **File Extension**: Always use `.txt` for Lua scripts in mod content
- **Directory Structure**: Place scripts in `Assets/Build/{ModName}/Script/` directory
- **Naming Convention**: Use descriptive names indicating functionality
  - `{ModName}Script.txt` - Main mod logic
  - `{ModName}Controller.txt` - Input and interaction handling
  - `{ModName}Utils.txt` - Utility functions
  - `{ModName}Effects.txt` - Visual and audio effects

### Script Organization Patterns
```lua
-- File header with module information
-- ModName: Magic Bow System
-- Author: Your Name
-- Version: 1.0.0
-- Description: Advanced magic bow with multiple spell types
-- Dependencies: CL.EffectManager, CL.AudioManager

-- Import required modules
local CL = require('CL')
local Utils = require('Utils')

-- Module-level constants
local MODULE_NAME = "MagicBow"
local VERSION = "1.0.0"
local DEBUG_MODE = false

-- Configuration tables
local CONFIG = {
    fireRate = 2.0,
    maxRange = 100.0,
    damageMultiplier = 1.5,
    -- ... other configuration
}

-- Main module definition
local MagicBow = {
    -- Public properties
    enabled = true,
    initialized = false,
    
    -- Private properties (prefixed with _)
    _components = {},
    _eventHandlers = {},
    _resources = {},
}
```

## Core Lua Patterns and Best Practices

### 1. Object-Oriented Structure
```lua
-- Standard mod class pattern
local WeaponController = {
    -- Static configuration
    CLASS_NAME = "WeaponController",
    DEFAULT_DAMAGE = 25,
    
    -- Instance properties
    isActive = false,
    currentAmmo = 0,
    maxAmmo = 30,
    
    -- Private state
    _isReloading = false,
    _lastFireTime = 0,
    _audioSources = {},
}

-- Constructor-like initialization
function WeaponController:Initialize(host, config)
    self.host = host
    self.config = config or {}
    
    -- Initialize components
    self:SetupComponents()
    self:RegisterEventHandlers()
    self:LoadResources()
    
    self.initialized = true
    self:Log("Weapon controller initialized successfully")
    
    return self
end

-- Proper inheritance pattern
function WeaponController:Extend(childClass)
    childClass = childClass or {}
    setmetatable(childClass, { __index = self })
    return childClass
end

-- Example of specialized weapon
local MagicWeapon = WeaponController:Extend({
    spellType = "Fire",
    manaConsumption = 10,
    _spellEffects = {},
})

function MagicWeapon:CastSpell(target)
    if not self:CanCastSpell() then
        return false
    end
    
    self:ConsumeSpell()
    self:CreateSpellEffect(target)
    return true
end
```

### 2. Error Handling and Validation
```lua
-- Robust error handling patterns
function WeaponController:SafeExecute(func, ...)
    local success, result = pcall(func, self, ...)
    
    if not success then
        self:LogError("Function execution failed: " .. tostring(result))
        return nil, result
    end
    
    return result
end

-- Input validation utilities
function WeaponController:ValidateGameObject(obj, objName)
    if IsNullOrDestroyed(obj) then
        self:LogError(string.format("%s is null or destroyed", objName or "GameObject"))
        return false
    end
    return true
end

function WeaponController:ValidateNumber(value, min, max, name)
    if type(value) ~= "number" then
        self:LogError(string.format("%s must be a number, got %s", name, type(value)))
        return false
    end
    
    if min and value < min then
        self:LogWarning(string.format("%s (%f) is below minimum (%f)", name, value, min))
        return false
    end
    
    if max and value > max then
        self:LogWarning(string.format("%s (%f) exceeds maximum (%f)", name, value, max))
        return false
    end
    
    return true
end

-- Safe property access
function WeaponController:GetSafeProperty(obj, propertyPath, defaultValue)
    local current = obj
    local path = {}
    
    for part in string.gmatch(propertyPath, "[^%.]+") do
        table.insert(path, part)
    end
    
    for _, property in ipairs(path) do
        if current == nil or IsNullOrDestroyed(current) then
            self:LogWarning("Property path broken at: " .. table.concat(path, ".", 1, _))
            return defaultValue
        end
        current = current[property]
    end
    
    return current ~= nil and current or defaultValue
end
```

### 3. Performance Optimization Patterns
```lua
-- Efficient update patterns
function WeaponController:Start()
    -- Cache frequently accessed components
    self._transform = self.host.transform
    self._rigidbody = self.host:GetComponent("Rigidbody")
    self._audioSource = self.host:GetComponent("AudioSource")
    
    -- Pre-calculate constants
    self._fireRateInterval = 1.0 / self.fireRate
    self._maxRangeSquared = self.maxRange * self.maxRange
    
    -- Initialize object pools
    self:InitializeObjectPools()
    
    -- Setup periodic updates instead of per-frame
    self:SetupPeriodicUpdates()
end

function WeaponController:SetupPeriodicUpdates()
    -- Use scheduler for non-critical updates
    self._updateScheduleId = CL.Scheduler.Create(self.host, 
        function(scheduler, time, step)
            self:PeriodicUpdate()
        end,
    0.1, -1) -- Update every 100ms instead of every frame
end

-- Object pooling for frequently created objects
function WeaponController:InitializeObjectPools()
    self._projectilePool = {
        available = {},
        active = {},
        maxSize = 20,
    }
    
    -- Pre-populate pool
    for i = 1, self._projectilePool.maxSize do
        local projectile = self:CreatePooledProjectile()
        table.insert(self._projectilePool.available, projectile)
    end
end

function WeaponController:GetPooledProjectile()
    local pool = self._projectilePool
    
    if #pool.available > 0 then
        local projectile = table.remove(pool.available)
        table.insert(pool.active, projectile)
        return projectile
    end
    
    -- Pool exhausted, create new instance
    local projectile = self:CreatePooledProjectile()
    table.insert(pool.active, projectile)
    return projectile
end

function WeaponController:ReturnProjectileToPool(projectile)
    local pool = self._projectilePool
    
    -- Find and remove from active list
    for i, activeProjectile in ipairs(pool.active) do
        if activeProjectile == projectile then
            table.remove(pool.active, i)
            break
        end
    end
    
    -- Reset projectile state
    projectile:SetActive(false)
    projectile.transform.position = UE.Vector3.zero
    
    -- Return to available pool
    table.insert(pool.available, projectile)
end
```

## BattleTalent API Integration

### 1. CL Framework Usage
```lua
-- Audio system integration
function WeaponController:PlayAudio(audioClip, volume, pitch)
    if not self:ValidateGameObject(self._audioSource, "AudioSource") then
        return
    end
    
    volume = volume or 1.0
    pitch = pitch or 1.0
    
    -- Use CL audio system for proper VR audio spatialization
    CL.AudioManager.PlayClipAtPosition(
        audioClip,
        self._transform.position,
        volume,
        pitch,
        self.host
    )
end

-- Effect system integration
function WeaponController:PlayVisualEffect(effectName, duration, scale)
    duration = duration or 2.0
    scale = scale or 1.0
    
    local effect = CL.EffectManager.PlayEffect(
        effectName,
        self._transform.position,
        self._transform.rotation,
        duration
    )
    
    if not IsNullOrDestroyed(effect) then
        effect.transform.localScale = UE.Vector3.one * scale
        
        -- Store reference for cleanup
        table.insert(self._activeEffects, effect)
    end
    
    return effect
end

-- Input system integration
function WeaponController:HandleVRInput()
    local hand = self.host.interact:GetPrimaryHand()
    if IsNullOrDestroyed(hand) then
        return
    end
    
    local inputDevice = hand:GetInputDevice()
    if IsNullOrDestroyed(inputDevice) then
        return
    end
    
    -- Get trigger input
    local triggerValue = inputDevice:GetTriggerAxis()
    if triggerValue > 0.8 then
        self:OnTriggerPressed()
    end
    
    -- Get grip input
    local gripValue = inputDevice:GetGripAxis()
    if gripValue > 0.8 then
        self:OnGripPressed()
    end
    
    -- Get touchpad/joystick input for spell switching
    local touchpad = inputDevice:GetTouchpadAxis()
    if touchpad.magnitude > 0.7 then
        self:HandleSpellSwitch(touchpad)
    end
end
```

### 2. Physics and Collision Handling
```lua
-- VR physics integration
function WeaponController:SetupVRPhysics()
    if not self:ValidateGameObject(self._rigidbody, "Rigidbody") then
        return
    end
    
    -- Configure for VR interaction
    self._rigidbody.interpolation = UE.RigidbodyInterpolation.Interpolate
    self._rigidbody.collisionDetectionMode = UE.CollisionDetectionMode.Continuous
    
    -- Set up collision ignore patterns
    self:SetupCollisionIgnores()
end

function WeaponController:SetupCollisionIgnores()
    local weaponCols = self.host.interact:GetCols()
    local playerCols = CL.InteractCharacter.AIPlayerInstance.ra:GetCols()
    
    -- Ignore collisions between weapon and player initially
    CL.PhysicsHelper.IgnoreCollisions(weaponCols, playerCols, true)
    
    -- Schedule collision re-enable after brief delay
    CL.Scheduler.Create(self.host,
        function()
            CL.PhysicsHelper.IgnoreCollisions(weaponCols, playerCols, false)
        end,
    0, 0, 0.5) -- Re-enable after 0.5 seconds
end

-- Projectile physics
function WeaponController:FireProjectile(direction, speed)
    local projectile = self:GetPooledProjectile()
    if not projectile then
        self:LogError("Failed to get projectile from pool")
        return
    end
    
    -- Set projectile properties
    projectile.transform.position = self:GetFirePoint()
    projectile.transform.rotation = UE.Quaternion.LookRotation(direction)
    
    local projectileRb = projectile:GetComponent("Rigidbody")
    if projectileRb then
        projectileRb.velocity = direction * speed
        
        -- Apply custom physics if needed
        self:ApplyProjectilePhysics(projectileRb)
    end
    
    projectile:SetActive(true)
    
    -- Schedule automatic cleanup
    CL.Scheduler.Create(self.host,
        function()
            self:ReturnProjectileToPool(projectile)
        end,
    0, 0, 10.0) -- Return to pool after 10 seconds
end
```

### 3. Networking and Multiplayer Support
```lua
-- Network synchronization patterns
function WeaponController:SyncNetworkState()
    if not CL.NetworkManager.IsNetworked() then
        return -- Single player mode
    end
    
    local networkData = {
        ammo = self.currentAmmo,
        spellType = self.spellType,
        isReloading = self._isReloading,
        lastFireTime = self._lastFireTime,
    }
    
    -- Send state to other players
    CL.NetworkManager.SendModData(self.CLASS_NAME, networkData)
end

function WeaponController:OnNetworkDataReceived(senderId, data)
    if senderId == CL.NetworkManager.GetLocalPlayerId() then
        return -- Ignore own data
    end
    
    -- Apply received state
    self.currentAmmo = data.ammo or self.currentAmmo
    self.spellType = data.spellType or self.spellType
    self._isReloading = data.isReloading or false
    
    -- Update visual representation
    self:UpdateNetworkVisuals()
end

-- Authoritative actions for multiplayer
function WeaponController:RequestFire(target)
    if not CL.NetworkManager.IsNetworked() then
        -- Single player - execute immediately
        return self:ExecuteFire(target)
    end
    
    if CL.NetworkManager.IsHost() then
        -- Host has authority - execute and broadcast
        local result = self:ExecuteFire(target)
        if result then
            self:BroadcastFireAction(target)
        end
        return result
    else
        -- Client - send request to host
        CL.NetworkManager.SendHostRequest("WeaponFire", {
            weaponId = self:GetNetworkId(),
            target = target,
            timestamp = CL.Time.NetworkTime()
        })
        return false -- Will be confirmed by host
    end
end
```

## Advanced Scripting Patterns

### 1. State Machine Implementation
```lua
-- Finite state machine for weapon behavior
local WeaponState = {
    IDLE = "idle",
    FIRING = "firing",
    RELOADING = "reloading",
    OVERHEATED = "overheated",
    DISABLED = "disabled"
}

function WeaponController:InitializeStateMachine()
    self._currentState = WeaponState.IDLE
    self._stateTime = 0
    self._stateMachine = {
        [WeaponState.IDLE] = {
            enter = function() self:OnIdleEnter() end,
            update = function(dt) self:OnIdleUpdate(dt) end,
            exit = function() self:OnIdleExit() end,
            transitions = {
                [WeaponState.FIRING] = function() return self:CanFire() end,
                [WeaponState.RELOADING] = function() return self:ShouldReload() end,
            }
        },
        [WeaponState.FIRING] = {
            enter = function() self:OnFiringEnter() end,
            update = function(dt) self:OnFiringUpdate(dt) end,
            exit = function() self:OnFiringExit() end,
            transitions = {
                [WeaponState.IDLE] = function() return self._stateTime > self._fireRateInterval end,
                [WeaponState.RELOADING] = function() return self.currentAmmo <= 0 end,
            }
        },
        -- ... other states
    }
end

function WeaponController:UpdateStateMachine(deltaTime)
    self._stateTime = self._stateTime + deltaTime
    
    local currentStateData = self._stateMachine[self._currentState]
    if currentStateData and currentStateData.update then
        currentStateData.update(deltaTime)
    end
    
    -- Check for state transitions
    self:CheckStateTransitions()
end

function WeaponController:ChangeState(newState)
    if newState == self._currentState then
        return
    end
    
    -- Exit current state
    local currentStateData = self._stateMachine[self._currentState]
    if currentStateData and currentStateData.exit then
        currentStateData.exit()
    end
    
    local oldState = self._currentState
    self._currentState = newState
    self._stateTime = 0
    
    -- Enter new state
    local newStateData = self._stateMachine[newState]
    if newStateData and newStateData.enter then
        newStateData.enter()
    end
    
    self:Log(string.format("State changed: %s -> %s", oldState, newState))
end
```

### 2. Event System Implementation
```lua
-- Event-driven architecture
function WeaponController:InitializeEventSystem()
    self._eventHandlers = {}
    self._eventQueue = {}
    
    -- Register for common game events
    self:RegisterEventHandler("PlayerDamaged", function(data) self:OnPlayerDamaged(data) end)
    self:RegisterEventHandler("AmmoChanged", function(data) self:OnAmmoChanged(data) end)
    self:RegisterEventHandler("SpellChanged", function(data) self:OnSpellChanged(data) end)
end

function WeaponController:RegisterEventHandler(eventName, handler)
    if not self._eventHandlers[eventName] then
        self._eventHandlers[eventName] = {}
    end
    table.insert(self._eventHandlers[eventName], handler)
end

function WeaponController:FireEvent(eventName, eventData)
    -- Add to queue for next update cycle to avoid recursion
    table.insert(self._eventQueue, {name = eventName, data = eventData})
end

function WeaponController:ProcessEventQueue()
    while #self._eventQueue > 0 do
        local event = table.remove(self._eventQueue, 1)
        self:ProcessEvent(event.name, event.data)
    end
end

function WeaponController:ProcessEvent(eventName, eventData)
    local handlers = self._eventHandlers[eventName]
    if not handlers then
        return
    end
    
    for _, handler in ipairs(handlers) do
        local success, error = pcall(handler, eventData)
        if not success then
            self:LogError(string.format("Event handler failed for %s: %s", eventName, error))
        end
    end
end
```

### 3. Configuration and Serialization
```lua
-- Configuration management
function WeaponController:LoadConfiguration()
    local configPath = string.format("Config/%s_Config", self.CLASS_NAME)
    local configAsset = CL.AssetManager.LoadAsset(configPath)
    
    if configAsset then
        self.config = self:DeserializeConfig(configAsset.text)
    else
        self.config = self:GetDefaultConfig()
        self:LogWarning("Config not found, using defaults")
    end
    
    self:ApplyConfiguration()
end

function WeaponController:GetDefaultConfig()
    return {
        damage = 25,
        fireRate = 2.0,
        maxAmmo = 30,
        reloadTime = 2.5,
        audioVolume = 0.8,
        effectScale = 1.0,
        vr = {
            hapticIntensity = 0.7,
            hapticDuration = 0.1,
        }
    }
end

function WeaponController:ApplyConfiguration()
    self.damage = self.config.damage or self.damage
    self.fireRate = self.config.fireRate or self.fireRate
    self.maxAmmo = self.config.maxAmmo or self.maxAmmo
    
    -- Apply VR-specific settings
    if self.config.vr then
        self._hapticIntensity = self.config.vr.hapticIntensity or 0.7
        self._hapticDuration = self.config.vr.hapticDuration or 0.1
    end
end

-- Save player preferences
function WeaponController:SaveUserPreferences()
    local preferences = {
        spellType = self.spellType,
        audioEnabled = self.audioEnabled,
        customizations = self.customizations,
    }
    
    local prefString = self:SerializeTable(preferences)
    CL.PlayerPrefs.SetString(self.CLASS_NAME .. "_Prefs", prefString)
end
```

## Debugging and Logging

### Enhanced Logging System
```lua
-- Comprehensive logging with different levels
function WeaponController:Log(message, level)
    level = level or "INFO"
    local timestamp = CL.Time.GetTimeString()
    local logMessage = string.format("[%s][%s][%s]: %s", 
        timestamp, self.CLASS_NAME, level, message)
    
    if level == "ERROR" then
        print("ERROR: " .. logMessage)
        -- Also log to file if available
        self:LogToFile(logMessage)
    elseif level == "WARNING" then
        print("WARNING: " .. logMessage)
    elseif DEBUG_MODE or level == "INFO" then
        print(logMessage)
    end
end

function WeaponController:LogError(message)
    self:Log(message, "ERROR")
end

function WeaponController:LogWarning(message)
    self:Log(message, "WARNING")
end

function WeaponController:LogDebug(message)
    if DEBUG_MODE then
        self:Log(message, "DEBUG")
    end
end

-- Performance monitoring
function WeaponController:ProfileFunction(funcName, func, ...)
    local startTime = CL.Time.GetRealTime()
    local result = func(...)
    local endTime = CL.Time.GetRealTime()
    local duration = endTime - startTime
    
    if duration > 0.01 then -- Log if function takes more than 10ms
        self:LogWarning(string.format("Performance: %s took %.3fs", funcName, duration))
    end
    
    return result
end
```

## Module Export Pattern
```lua
-- Standard module export with cleanup
function WeaponController:OnDestroy()
    -- Essential cleanup
    self.enabled = false
    self.initialized = false
    
    -- Clean up scheduled tasks
    if self._updateScheduleId then
        CL.Scheduler.RemoveSchedule(self._updateScheduleId)
    end
    
    -- Clean up event handlers
    self._eventHandlers = {}
    self._eventQueue = {}
    
    -- Clean up object pools
    self:CleanupObjectPools()
    
    -- Release audio resources
    self:CleanupAudioResources()
    
    -- Release visual effects
    self:CleanupVisualEffects()
    
    self:Log("Weapon controller destroyed and cleaned up")
end

-- Return the class using BattleTalent's class system
return Class(nil, nil, WeaponController)
```
