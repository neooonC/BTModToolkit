---
title: "C# Development Standards for BattleTalent Mods"
description: "Comprehensive coding standards and best practices for C# development in Unity VR mod environment"
type: "standards"
globs: ["**/*.cs", "Assets/Scripts/**/*", "Assets/Build/**/*.cs"]
alwaysApply: true
tags: ["csharp", "coding-standards", "unity", "performance", "vr"]
---

# C# Development Standards for BattleTalent Mods

## Code Organization and Namespace Structure

### Namespace Hierarchy
```csharp
// Core mod namespace
namespace CrossLink.Mods.{ModName}
{
    // Main mod classes
}

// Utilities shared across mods
namespace CrossLink.Utils
{
    // Utility classes, extensions, helpers
}

// VR-specific implementations
namespace CrossLink.VR
{
    // VR interaction, input handling, physics
}

// Networking components
namespace CrossLink.Networking
{
    // Mirror networking, multiplayer sync
}
```

### File and Class Organization
- One public class per file
- File name matches class name exactly
- Use descriptive, intention-revealing names
- Group related functionality in folders
- Keep classes focused on single responsibility

## Coding Standards and Conventions

### Naming Conventions
```csharp
// Classes, Methods, Properties, Public Fields - PascalCase
public class WeaponController
{
    public int MaxAmmo { get; set; }
    public GameObject WeaponPrefab;
    
    public void ReloadWeapon() { }
}

// Private fields - camelCase with underscore prefix
private int _currentAmmo;
private Transform _firePoint;
private bool _isReloading;

// Local variables, parameters - camelCase
public void FireProjectile(Vector3 targetPosition, float fireRate)
{
    var projectileInstance = Instantiate(projectilePrefab);
    // ...
}

// Constants - UPPER_SNAKE_CASE
public const float MAX_WEAPON_RANGE = 100f;
private const string WEAPON_TAG = "ModWeapon";

// Events - PascalCase with descriptive action
public event Action<int> OnAmmoChanged;
public event Action OnWeaponFired;
```

### Code Quality Standards

#### 1. Documentation and Comments
```csharp
/// <summary>
/// Manages VR weapon interactions and firing mechanics for mod weapons.
/// Handles both single-shot and automatic firing modes with proper VR physics.
/// </summary>
/// <remarks>
/// This component should be attached to weapon prefabs that need VR interaction.
/// Requires a Rigidbody and appropriate colliders for VR physics.
/// </remarks>
public class VRWeaponController : MonoBehaviour, IWeapon, IDisposable
{
    /// <summary>
    /// The maximum number of projectiles this weapon can fire per second.
    /// Used to prevent spam-firing and maintain game balance.
    /// </summary>
    [Tooltip("Maximum fire rate in shots per second")]
    [Range(0.1f, 30f)]
    public float MaxFireRate = 5f;
    
    /// <summary>
    /// Attempts to fire the weapon if cooldown has elapsed and ammo is available.
    /// </summary>
    /// <param name="targetDirection">Direction to fire the projectile</param>
    /// <returns>True if weapon was fired successfully, false if on cooldown or out of ammo</returns>
    public bool TryFire(Vector3 targetDirection)
    {
        // Implementation with clear logic flow
    }
}
```

#### 2. Error Handling and Validation
```csharp
public class SafeModLoader
{
    public async Task<T> LoadModAssetAsync<T>(string assetPath) where T : UnityEngine.Object
    {
        // Validate input parameters
        if (string.IsNullOrWhiteSpace(assetPath))
        {
            throw new ArgumentException("Asset path cannot be null or empty", nameof(assetPath));
        }
        
        try
        {
            // Attempt asset loading with timeout
            var loadOperation = Addressables.LoadAssetAsync<T>(assetPath);
            var timeoutTask = Task.Delay(TimeSpan.FromSeconds(30));
            
            var completedTask = await Task.WhenAny(loadOperation.Task, timeoutTask);
            
            if (completedTask == timeoutTask)
            {
                Debug.LogError($"Asset loading timed out: {assetPath}");
                Addressables.Release(loadOperation);
                return null;
            }
            
            return await loadOperation.Task;
        }
        catch (InvalidKeyException ex)
        {
            Debug.LogError($"Invalid addressable key '{assetPath}': {ex.Message}");
            return null;
        }
        catch (Exception ex)
        {
            Debug.LogError($"Failed to load asset '{assetPath}': {ex.Message}");
            return null;
        }
    }
}
```

#### 3. Resource Management and IDisposable Pattern
```csharp
public class ModComponentManager : MonoBehaviour, IDisposable
{
    private readonly List<AsyncOperationHandle> _assetHandles = new();
    private readonly List<IDisposable> _disposables = new();
    private CancellationTokenSource _cancellationTokenSource;
    private bool _disposed = false;
    
    protected virtual void OnDestroy()
    {
        Dispose();
    }
    
    public void Dispose()
    {
        if (_disposed) return;
        
        // Cancel any ongoing operations
        _cancellationTokenSource?.Cancel();
        _cancellationTokenSource?.Dispose();
        
        // Release addressable handles
        foreach (var handle in _assetHandles)
        {
            if (handle.IsValid())
                Addressables.Release(handle);
        }
        _assetHandles.Clear();
        
        // Dispose managed resources
        foreach (var disposable in _disposables)
        {
            disposable?.Dispose();
        }
        _disposables.Clear();
        
        _disposed = true;
    }
    
    protected void RegisterDisposable(IDisposable disposable)
    {
        if (!_disposed && disposable != null)
            _disposables.Add(disposable);
    }
}
```

## Unity-Specific Best Practices

### Component Design Patterns
```csharp
[System.Serializable]
public class WeaponStats
{
    [Header("Damage")]
    public float baseDamage = 10f;
    public DamageType damageType = DamageType.Physical;
    
    [Header("Performance")]
    public float fireRate = 1f;
    public int maxAmmo = 30;
    public float reloadTime = 2f;
    
    [Header("VR Physics")]
    public float projectileSpeed = 50f;
    public float gravityMultiplier = 1f;
    public LayerMask hitLayers = -1;
}

public class ModularWeapon : MonoBehaviour
{
    [SerializeField] private WeaponStats stats;
    [SerializeField] private VRInteractionProfile vrProfile;
    
    // Property wrapper for safe access
    public WeaponStats Stats => stats ?? (stats = new WeaponStats());
    
    // Unity lifecycle with proper order
    private void Awake()
    {
        // Initialize components and validate references
        ValidateConfiguration();
    }
    
    private void Start()
    {
        // Setup connections and register events
        InitializeWeapon();
    }
    
    private void OnValidate()
    {
        // Validate inspector settings (editor only)
        if (stats != null && stats.fireRate <= 0)
            stats.fireRate = 0.1f;
    }
}
```

### Performance Optimization Patterns

#### 1. Object Pooling
```csharp
public class ProjectilePool : MonoBehaviour
{
    [SerializeField] private GameObject projectilePrefab;
    [SerializeField] private int poolSize = 50;
    
    private Queue<GameObject> _poolQueue = new();
    private HashSet<GameObject> _activeProjectiles = new();
    
    private void Start()
    {
        InitializePool();
    }
    
    private void InitializePool()
    {
        for (int i = 0; i < poolSize; i++)
        {
            var projectile = Instantiate(projectilePrefab, transform);
            projectile.SetActive(false);
            _poolQueue.Enqueue(projectile);
        }
    }
    
    public GameObject GetProjectile()
    {
        if (_poolQueue.Count > 0)
        {
            var projectile = _poolQueue.Dequeue();
            _activeProjectiles.Add(projectile);
            projectile.SetActive(true);
            return projectile;
        }
        
        // Pool exhausted, create new instance
        var newProjectile = Instantiate(projectilePrefab);
        _activeProjectiles.Add(newProjectile);
        return newProjectile;
    }
    
    public void ReturnProjectile(GameObject projectile)
    {
        if (_activeProjectiles.Remove(projectile))
        {
            projectile.SetActive(false);
            projectile.transform.SetParent(transform);
            _poolQueue.Enqueue(projectile);
        }
    }
}
```

#### 2. Efficient Update Patterns
```csharp
// Avoid expensive operations in Update()
public class OptimizedWeaponSystem : MonoBehaviour
{
    private float _lastUpdateTime;
    private const float UPDATE_INTERVAL = 0.1f; // 10 times per second instead of 60+
    
    private void Update()
    {
        if (Time.time - _lastUpdateTime >= UPDATE_INTERVAL)
        {
            PerformPeriodicUpdate();
            _lastUpdateTime = Time.time;
        }
    }
    
    private void PerformPeriodicUpdate()
    {
        // Only essential updates here
        CheckAmmoStatus();
        UpdateCooldowns();
    }
    
    // Use events for immediate responses instead of polling
    private void OnTriggerPull()
    {
        TryFireWeapon(); // Immediate response to input
    }
}
```

## VR-Specific Considerations

### Hand Tracking and Input
```csharp
public class VRWeaponGrip : MonoBehaviour
{
    [Header("VR Grip Settings")]
    public Transform primaryGripPoint;
    public Transform secondaryGripPoint;
    public HandPose primaryGripPose;
    public HandPose secondaryGripPose;
    
    private XRGrabInteractable _grabInteractable;
    private bool _isPrimaryGrabbed;
    private bool _isSecondaryGrabbed;
    
    protected virtual void Awake()
    {
        _grabInteractable = GetComponent<XRGrabInteractable>();
        SetupGrabCallbacks();
    }
    
    private void SetupGrabCallbacks()
    {
        _grabInteractable.selectEntered.AddListener(OnGrabEntered);
        _grabInteractable.selectExited.AddListener(OnGrabExited);
    }
    
    private void OnGrabEntered(SelectEnterEventArgs args)
    {
        var hand = args.interactorObject.transform.GetComponent<XRController>();
        if (hand != null)
        {
            ApplyHandPose(hand);
            ConfigureGripPhysics(true);
        }
    }
    
    private void ApplyHandPose(XRController controller)
    {
        // Apply appropriate hand pose based on grip point
        var isLeftHand = controller.controllerNode == XRNode.LeftHand;
        var pose = isLeftHand ? primaryGripPose : secondaryGripPose;
        
        if (pose != null)
        {
            // Apply hand pose animation
            controller.GetComponent<HandAnimator>()?.SetPose(pose);
        }
    }
}
```

### Physics and Collision
```csharp
public class VRProjectilePhysics : MonoBehaviour
{
    [Header("VR Physics")]
    public float gravityScale = 1f;
    public float airResistance = 0.1f;
    public AnimationCurve velocityFalloff;
    
    private Rigidbody _rb;
    private Vector3 _initialVelocity;
    private float _launchTime;
    
    private void Start()
    {
        _rb = GetComponent<Rigidbody>();
        _rb.useGravity = false; // Custom gravity for better VR feel
        _initialVelocity = _rb.velocity;
        _launchTime = Time.time;
    }
    
    private void FixedUpdate()
    {
        ApplyCustomPhysics();
    }
    
    private void ApplyCustomPhysics()
    {
        // Custom gravity that feels natural in VR
        var gravity = Physics.gravity * gravityScale;
        _rb.AddForce(gravity, ForceMode.Acceleration);
        
        // Air resistance for realistic trajectory
        var dragForce = -_rb.velocity.normalized * (airResistance * _rb.velocity.sqrMagnitude);
        _rb.AddForce(dragForce, ForceMode.Force);
        
        // Velocity falloff over time
        var timeSinceLaunch = Time.time - _launchTime;
        var velocityMultiplier = velocityFalloff.Evaluate(timeSinceLaunch);
        
        if (velocityMultiplier < 0.1f)
        {
            // Projectile has lost too much velocity, deactivate
            DeactivateProjectile();
        }
    }
}
```

## Testing and Debugging

### Unit Testing Framework
```csharp
using NUnit.Framework;
using UnityEngine;
using UnityEngine.TestTools;
using System.Collections;

[TestFixture]
public class WeaponSystemTests
{
    private GameObject weaponPrefab;
    private WeaponController weaponController;
    
    [SetUp]
    public void Setup()
    {
        weaponPrefab = Resources.Load<GameObject>("TestWeapon");
        var weaponInstance = Object.Instantiate(weaponPrefab);
        weaponController = weaponInstance.GetComponent<WeaponController>();
    }
    
    [Test]
    public void WeaponFiresWithValidAmmo()
    {
        // Arrange
        weaponController.SetAmmo(10);
        
        // Act
        bool fired = weaponController.TryFire(Vector3.forward);
        
        // Assert
        Assert.IsTrue(fired, "Weapon should fire when ammo is available");
        Assert.AreEqual(9, weaponController.CurrentAmmo, "Ammo should decrease after firing");
    }
    
    [UnityTest]
    public IEnumerator WeaponCooldownPreventsRapidFire()
    {
        // Arrange
        weaponController.SetAmmo(10);
        weaponController.FireRate = 1f; // 1 shot per second
        
        // Act
        bool firstShot = weaponController.TryFire(Vector3.forward);
        bool secondShot = weaponController.TryFire(Vector3.forward);
        
        // Assert
        Assert.IsTrue(firstShot, "First shot should succeed");
        Assert.IsFalse(secondShot, "Second shot should be blocked by cooldown");
        
        // Wait for cooldown
        yield return new WaitForSeconds(1.1f);
        
        bool thirdShot = weaponController.TryFire(Vector3.forward);
        Assert.IsTrue(thirdShot, "Third shot should succeed after cooldown");
    }
}
```

### Debug Logging Standards
```csharp
public static class ModLogger
{
    private static readonly string LOG_PREFIX = "[BT-Mod]";
    
    public static void Log(string message, Object context = null)
    {
        Debug.Log($"{LOG_PREFIX} {message}", context);
    }
    
    public static void LogWarning(string message, Object context = null)
    {
        Debug.LogWarning($"{LOG_PREFIX} WARNING: {message}", context);
    }
    
    public static void LogError(string message, Object context = null)
    {
        Debug.LogError($"{LOG_PREFIX} ERROR: {message}", context);
    }
    
    public static void LogPerformance(string operation, float duration, Object context = null)
    {
        if (duration > 0.016f) // Longer than one frame at 60fps
        {
            LogWarning($"Performance: {operation} took {duration:F3}s", context);
        }
    }
}
```
            {
                Debug.LogError($"Failed to load asset: {ex.Message}");
            }
        }
        
        public void Dispose()
        {
            if (_assetHandle.IsValid())
            {
                Addressables.Release(_assetHandle);
            }
        }
        
        private void OnDestroy()
        {
            Dispose();
        }
    }
}
```
