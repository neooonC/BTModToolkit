---
title: "VR Development Guidelines for BattleTalent Mods"
description: "Comprehensive VR development standards and best practices for creating immersive and comfortable VR experiences"
type: "standards"
globs: ["**/*VR*.cs", "Assets/XR/**/*", "**/*XR*.cs", "**/*.prefab"]
alwaysApply: false
tags: ["vr", "xr", "interaction", "comfort", "performance", "accessibility"]
---

# VR Development Guidelines for BattleTalent Mods

## VR Design Philosophy and Principles

### Core VR Design Tenets
1. **Comfort First**: Every design decision must prioritize user comfort and motion sickness prevention
2. **Natural Interaction**: VR interactions should feel intuitive and mimic real-world physics
3. **Spatial Awareness**: Design for 3D space with proper depth, scale, and spatial relationships
4. **Accessibility**: Support users with different physical capabilities and VR setups
5. **Performance**: Maintain high frame rates for immersion and comfort

### VR Comfort Guidelines
```csharp
// VR Comfort settings framework
[System.Serializable]
public class VRComfortSettings
{
    [Header("Motion Comfort")]
    [Range(0f, 1f)]
    public float vignetteIntensity = 0.7f;
    
    [Range(5f, 45f)]
    public float snapTurnAngle = 30f;
    
    public bool smoothLocomotion = true;
    public bool snapTurning = true;
    public bool teleportation = true;
    
    [Header("Visual Comfort")]
    public bool dynamicFOV = true;
    public bool comfortVignette = true;
    public bool reduceFlashing = true;
    
    [Header("Physical Comfort")]
    [Range(0.5f, 2f)]
    public float playAreaScale = 1f;
    
    public bool seatedMode = false;
    public bool armSwingLocomotion = false;
    
    [Header("Accessibility")]
    public bool oneHandedMode = false;
    public bool colorBlindSupport = true;
    public bool subtitles = true;
    public bool hapticReduction = false;
}

public class VRComfortManager : MonoBehaviour
{
    public VRComfortSettings settings;
    
    private void Start()
    {
        ApplyComfortSettings();
        SetupComfortMonitoring();
    }
    
    private void ApplyComfortSettings()
    {
        // Apply vignette during movement
        if (settings.comfortVignette)
        {
            SetupMovementVignette();
        }
        
        // Configure locomotion options
        ConfigureLocomotion();
        
        // Set up accessibility features
        SetupAccessibility();
    }
    
    private void SetupMovementVignette()
    {
        // Reduce peripheral vision during movement to prevent motion sickness
        var vignetteController = FindObjectOfType<VignetteController>();
        if (vignetteController != null)
        {
            vignetteController.enabled = true;
            vignetteController.intensity = settings.vignetteIntensity;
        }
    }
}
```

## VR Interaction System Architecture

### 1. Hand Pose and Gesture System
```csharp
[System.Serializable]
public class HandPoseDefinition
{
    [Header("Hand Pose Configuration")]
    public string poseName;
    public HandType handType; // Left, Right, or Both
    public float[] fingerFlexion = new float[5]; // Thumb to Pinky
    public Vector3 wristRotation;
    public float confidence = 0.8f; // Minimum confidence for recognition
    
    [Header("Interaction Properties")]
    public bool allowGrabbing = true;
    public bool allowPointing = false;
    public bool allowTeleport = false;
    public float grabStrength = 1f;
    
    [Header("Visual Feedback")]
    public Material handMaterial;
    public ParticleSystem gestureEffect;
    public AudioClip gestureSound;
}
```

### 2. Physics-Based VR Interactions
```csharp
// Example VR grabbable object with comprehensive physics
public class VRGrabbableWeapon : MonoBehaviour
{
    [Header("VR Settings")]
    public Transform gripPoint;
    public HandPoseAsset leftHandPose;
    public HandPoseAsset rightHandPose;
    
    [Header("Physics")]
    public float grabDistance = 0.1f;
    public LayerMask grabLayerMask = -1;
    public float throwMultiplier = 1.5f;
    public float hapticIntensity = 0.3f;
    
    private Rigidbody rb;
    private bool isGrabbed = false;
    private Vector3 lastHandVelocity;
    private XRGrabInteractable grabInteractable;
    
    private void Start()
    {
        rb = GetComponent<Rigidbody>();
        if (rb == null)
        {
            rb = gameObject.AddComponent<Rigidbody>();
        }
        
        // Configure for VR physics
        rb.interpolation = RigidbodyInterpolation.Interpolate;
        rb.collisionDetectionMode = CollisionDetectionMode.Continuous;
        
        // Setup XR grab interactable
        SetupXRInteraction();
    }
    
    private void SetupXRInteraction()
    {
        grabInteractable = GetComponent<XRGrabInteractable>();
        if (grabInteractable == null)
        {
            grabInteractable = gameObject.AddComponent<XRGrabInteractable>();
        }
        
        grabInteractable.selectEntered.AddListener(OnGrabEntered);
        grabInteractable.selectExited.AddListener(OnGrabExited);
    }
    
    private void OnGrabEntered(SelectEnterEventArgs args)
    {
        isGrabbed = true;
        
        // Apply hand pose
        ApplyHandPose(args.interactorObject.transform);
        
        // Trigger haptic feedback
        TriggerHaptics(args.interactorObject.transform, hapticIntensity);
        
        // Set physics state
        rb.isKinematic = true;
    }
    
    private void OnGrabExited(SelectExitEventArgs args)
    {
        isGrabbed = false;
        rb.isKinematic = false;
        
        // Apply throwing physics
        ApplyThrowPhysics(args.interactorObject.transform);
        
        // Light haptic feedback on release
        TriggerHaptics(args.interactorObject.transform, hapticIntensity * 0.3f);
    }
    
    private void ApplyHandPose(Transform hand)
    {
        // Determine which hand is grabbing
        bool isLeftHand = hand.name.ToLower().Contains("left");
        var targetPose = isLeftHand ? leftHandPose : rightHandPose;
        
        if (targetPose != null)
        {
            // Apply pose to hand (implementation depends on hand tracking system)
            var handAnimator = hand.GetComponent<HandAnimator>();
            handAnimator?.SetPose(targetPose);
        }
    }
    
    private void ApplyThrowPhysics(Transform hand)
    {
        // Get hand velocity from XR controller
        var controller = hand.GetComponent<XRController>();
        if (controller != null)
        {
            controller.inputDevice.TryGetFeatureValue(CommonUsages.deviceVelocity, out Vector3 velocity);
            controller.inputDevice.TryGetFeatureValue(CommonUsages.deviceAngularVelocity, out Vector3 angularVelocity);
            
            // Apply velocity with throw multiplier
            rb.velocity = velocity * throwMultiplier;
            rb.angularVelocity = angularVelocity;
        }
    }
    
    private void TriggerHaptics(Transform hand, float intensity)
    {
        var controller = hand.GetComponent<XRController>();
        if (controller != null)
        {
            controller.SendHapticImpulse(intensity, 0.1f);
        }
    }
}
```

## Performance Optimization for VR

### Frame Rate Management
```csharp
public class VRPerformanceManager : MonoBehaviour
{
    [Header("Performance Targets")]
    public float targetFrameRate = 90f; // PC VR
    public float questTargetFrameRate = 72f; // Quest
    
    [Header("Quality Settings")]
    public bool enableAdaptiveQuality = true;
    public float fpsThresholdLow = 80f;
    public float fpsThresholdHigh = 85f;
    
    private void Start()
    {
        // Set appropriate target frame rate
        float targetFPS = Application.platform == RuntimePlatform.Android ? 
            questTargetFrameRate : targetFrameRate;
        Application.targetFrameRate = (int)targetFPS;
        
        // Enable performance monitoring
        if (enableAdaptiveQuality)
        {
            InvokeRepeating(nameof(MonitorPerformance), 1f, 1f);
        }
    }
    
    private void MonitorPerformance()
    {
        float currentFPS = 1f / Time.smoothDeltaTime;
        
        if (currentFPS < fpsThresholdLow)
        {
            ReduceQuality();
        }
        else if (currentFPS > fpsThresholdHigh)
        {
            IncreaseQuality();
        }
    }
}
```

## Audio Design for VR

### Spatial Audio Implementation
```csharp
public class VRSpatialAudio : MonoBehaviour
{
    [Header("Spatial Audio")]
    public bool enableSpatialAudio = true;
    public float maxDistance = 50f;
    public AnimationCurve volumeFalloff;
    
    [Header("VR Audio Settings")]
    public bool enableHRTF = true;
    public float reverbZoneInfluence = 1f;
    
    private AudioSource audioSource;
    
    private void Start()
    {
        audioSource = GetComponent<AudioSource>();
        ConfigureForVR();
    }
    
    private void ConfigureForVR()
    {
        if (audioSource != null)
        {
            // Enable 3D spatial audio
            audioSource.spatialBlend = 1f;
            audioSource.rolloffMode = AudioRolloffMode.Custom;
            audioSource.maxDistance = maxDistance;
            
            // Apply custom volume falloff
            if (volumeFalloff != null)
            {
                audioSource.SetCustomCurve(AudioSourceCurveType.CustomRolloff, volumeFalloff);
            }
            
            // Enable HRTF if supported
            if (enableHRTF && AudioSettings.GetSpatializerPluginName() != "")
            {
                audioSource.spatialize = true;
            }
        }
    }
}
```

## Comfort and Accessibility Features

### Motion Sickness Prevention
```csharp
public class VRComfortSystem : MonoBehaviour
{
    [Header("Comfort Options")]
    public bool teleportLocomotion = true;
    public bool smoothLocomotion = false;
    public bool snapTurning = true;
    public float snapTurnDegrees = 30f;
    
    [Header("Visual Comfort")]
    public bool movementVignette = true;
    public float vignetteStrength = 0.7f;
    public bool reduceFOVOnMovement = true;
    
    public void EnableComfortFeature(string featureName, bool enabled)
    {
        switch (featureName.ToLower())
        {
            case "teleport":
                teleportLocomotion = enabled;
                ConfigureTeleportation();
                break;
            case "smooth":
                smoothLocomotion = enabled;
                ConfigureSmoothLocomotion();
                break;
            case "snapturn":
                snapTurning = enabled;
                ConfigureSnapTurning();
                break;
            case "vignette":
                movementVignette = enabled;
                ConfigureMovementVignette();
                break;
        }
    }
}
```

This comprehensive VR development guide ensures that BattleTalent mods provide comfortable, accessible, and high-performance VR experiences across all supported platforms.
