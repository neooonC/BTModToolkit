---
title: "Lua VR Mod Development Patterns"
description: "Essential Lua patterns for VR mod code generation"
type: "patterns"
globs: ["Assets/Build/**/Script/**/*.txt", "**/*.lua"]
alwaysApply: true
tags: ["lua", "vr", "api", "patterns"]
---

# Lua VR Mod Development Patterns

## Core Module Structure
```lua
local {ModName} = {
    enabled = true,
    initialized = false,
    _config = {},
    _handlers = {},
    _resources = {},
}

function {ModName}:Awake()
    self:InitializeHandlers()
    self:LoadConfig()
    self.initialized = true
end

return {ModName}
```

## VR Event Handlers
```lua
function Module:InitializeHandlers()
    -- VR grab/release events
    self._grabHandler = function(grabInfo) self:OnGrab(grabInfo) end
    self._releaseHandler = function(releaseInfo) self:OnRelease(releaseInfo) end
    
    -- VR stab events (for weapons)
    self._stabEnterHandler = function(stabInfo) self:OnStab(stabInfo) end
    self._stabExitHandler = function(stabInfo) self:OnStabExit(stabInfo) end
    
    -- Register with C# layer
    if self.host and self.host.interact then
        local stabObject = self.host.interact:GetStabObject()
        if stabObject then
            stabObject:StabEnterEvent("+", self._stabEnterHandler)
            stabObject:StabExitEvent("+", self._stabExitHandler)
        end
    end
end

function Module:OnGrab(grabInfo)
    local handType = grabInfo.handType -- "Left" or "Right"
    local grabStrength = grabInfo.strength
    
    if grabStrength > 0.8 then
        self:OnFullGrab(handType)
    else
        self:OnPartialGrab(handType, grabStrength)
    end
end
```

## Essential APIs

### Unity Engine APIs (UE namespace)
```lua
-- Time and math essentials
UE.Time.time, UE.Time.deltaTime, UE.Time.frameCount
UE.Vector3.Lerp(from, to, t), UE.Vector3.Dot(a, b)
UE.Quaternion.LookRotation(forward, up)
UE.GameObject(name), UE.Object.Destroy(obj, delay)
UE.Physics.Raycast(origin, direction, distance)
UE.Debug.Log(message), UE.Debug.LogError(message)
```

### CrossLink Core APIs (CL namespace)
```lua
-- Resource Management
CL.ResourceMgr.Load(address), CL.ResourceMgr.LoadAsync(address, callback)
CL.ResourceMgr.Instantiate(address), CL.ResourceMgr.Instantiate(address, pos, rot)

-- Effect and Audio
CL.EffectMgr.Instance:PlayEffect(name, pos, rot)
CL.AudioMgr.Instance:GiveBackAndLerpToZero(soundInfo)

-- Scheduler and FlyObject
CL.Scheduler.Create(target, action), CL.Scheduler.RemoveSchedule(actionId)
CL.FlyObject.CreateFlyObj(prefab, source, pos, dir)
```

### Event System
```lua
-- LuaFunction â†’ Actual Event mapping
function Module:OnAwake()     -- Called by AwakeInit
    self:Initialize()
end

function Module:OnStart()     -- Called by StartInit  
    self:BeginLogic()
end
```

## VR Component Setup
```lua
function Module:SetupComponents()
    -- Essential VR Components
    self.weapon = self.host.interact:GetComponent("InteractWeapon")
    self.trigger = self.host.interact:GetComponent("InteractTriggerX")
    self.stabObj = self.host.interact:GetStabObject()
    self.hitInfo = self.host.interact:GetComponent("RagdollHitInfoObj")
    
    -- FlyObject setup for projectiles
    self.flyObj = self.host:GetComponent("FlyObjX")
    if self.flyObj then
        self.flyObj:OnHit(function(hitInfo) self:OnProjectileHit(hitInfo) end)
    end
end
```

## Common Patterns

### State Manager Pattern
```lua
local StateManager = {
    currentState = "idle",
    states = {},
    _stateData = {},
    _lastStateChange = 0,
}

function StateManager:ChangeState(newState, data)
    if self.currentState == newState then return false end
    
    self:ExitState(self.currentState)
    self.currentState = newState
    self._stateData = data or {}
    self._lastStateChange = UE.Time.time
    self:EnterState(newState)
    return true
end

function StateManager:CanChangeState(newState)
    return self.states[newState] ~= nil
        and self.currentState ~= newState
end
```

### Resource Cache Pattern
```lua
local ResourceCache = {
    _cache = {},
    _loadingQueue = {},
    maxCacheSize = 50,
}

function ResourceCache:GetResource(address, callback)
    if self._cache[address] then
        if callback then callback(self._cache[address]) end
        return self._cache[address]
    end
    
    if not self._loadingQueue[address] then
        self._loadingQueue[address] = {}
        CL.ResourceMgr.LoadAsync(address, function(asset)
            self:OnResourceLoaded(address, asset)
        end)
    end
    
    if callback then
        table.insert(self._loadingQueue[address], callback)
    end
end

function ResourceCache:OnResourceLoaded(address, asset)
    self._cache[address] = asset
    
    -- Execute queued callbacks
    if self._loadingQueue[address] then
        for _, callback in ipairs(self._loadingQueue[address]) do
            callback(asset)
        end
        self._loadingQueue[address] = nil
    end
end
```
