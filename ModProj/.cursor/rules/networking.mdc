---
title: "Networking and Multiplayer for BattleTalent Mods"
description: "Comprehensive guide for implementing multiplayer functionality using Mirror networking framework"
type: "patterns"
globs: ["**/*Network*.cs", "Assets/Mirror/**/*", "**/*Multiplayer*.cs", "Assets/Build/**/*Network*/**/*"]
alwaysApply: false
tags: ["networking", "multiplayer", "mirror", "synchronization", "authority"]
---

# Networking and Multiplayer for BattleTalent Mods

## Mirror Networking Architecture

### Core Networking Principles
BattleTalent uses Mirror Networking for all multiplayer functionality. Understanding these core concepts is essential:

- **Authority**: Only the client/server with authority can modify networked objects
- **Client-Server Model**: Host acts as both client and server
- **Prediction**: Client-side prediction for responsive gameplay
- **Reconciliation**: Server validation and correction of client actions

### Network Identity Setup
```csharp
using Mirror;
using UnityEngine;

[RequireComponent(typeof(NetworkIdentity))]
public class NetworkedWeapon : NetworkBehaviour
{
    [Header("Network Configuration")]
    [SyncVar(hook = nameof(OnWeaponStateChanged))]
    public WeaponState weaponState = WeaponState.Idle;
    
    [SyncVar(hook = nameof(OnAmmoChanged))]
    public int currentAmmo = 30;
    
    [SyncVar]
    public float damage = 25f;
    
    [SyncVar]
    public string weaponOwner;
    
    // Network-synced events
    public System.Action<WeaponState> OnWeaponStateNetworkChanged;
    public System.Action<int> OnAmmoNetworkChanged;
    
    protected virtual void Start()
    {
        // Only initialize on objects we have authority over
        if (hasAuthority)
        {
            InitializeWeapon();
        }
        
        // All clients listen for network changes
        RegisterNetworkCallbacks();
    }
    
    protected virtual void OnDestroy()
    {
        UnregisterNetworkCallbacks();
    }
}
```

## Client-Server Communication Patterns

### 1. Command Pattern (Client to Server)
```csharp
public class NetworkedWeapon : NetworkBehaviour
{
    [Header("Weapon Settings")]
    public float fireRate = 2f;
    public int maxAmmo = 30;
    
    private float _lastFireTime;
    private bool _isReloading;
    
    // Client requests action from server
    [Command]
    public void CmdFireWeapon(Vector3 targetPosition, Vector3 aimDirection)
    {
        // Server validation with comprehensive checks
        if (!CanFire())
        {
            Debug.LogWarning($"Player {connectionToClient} attempted invalid fire");
            return;
        }
        
        // Rate limiting
        if (Time.time - _lastFireTime < (1f / fireRate))
        {
            Debug.LogWarning($"Player {connectionToClient} firing too fast");
            return;
        }
        
        // Ammo validation
        if (currentAmmo <= 0)
        {
            Debug.LogWarning($"Player {connectionToClient} attempted to fire with no ammo");
            return;
        }
        
        // Server performs authoritative action
        _lastFireTime = Time.time;
        currentAmmo = Mathf.Max(0, currentAmmo - 1);
        
        PerformWeaponFire(targetPosition, aimDirection);
        
        // Notify all clients of the fire event
        RpcOnWeaponFired(targetPosition, aimDirection, connectionToClient.connectionId);
    }
    
    [Command]
    public void CmdReloadWeapon()
    {
        if (_isReloading || currentAmmo >= maxAmmo)
            return;
            
        StartCoroutine(ReloadSequence());
    }
    
    [Command]
    public void CmdSwitchWeaponMode(int modeIndex)
    {
        if (!IsValidWeaponMode(modeIndex))
        {
            Debug.LogWarning($"Invalid weapon mode: {modeIndex}");
            return;
        }
        
        weaponState = (WeaponState)modeIndex;
        RpcOnWeaponModeChanged(modeIndex);
    }
    
    // Server-side validation
    private bool CanFire()
    {
        return currentAmmo > 0 
            && !_isReloading 
            && Time.time - _lastFireTime >= (1f / fireRate)
            && weaponState == WeaponState.Ready;
    }
    
    private void PerformWeaponFire(Vector3 target, Vector3 direction)
    {
        _lastFireTime = Time.time;
        currentAmmo--; // SyncVar automatically syncs to clients
        
        // Create projectile on server
        CreateProjectile(target, direction);
        
        // Apply weapon effects
        ApplyWeaponEffects();
    }
}
```

### 2. ClientRpc Pattern (Server to All Clients)
```csharp
public class NetworkedWeapon : NetworkBehaviour
{
    // Server notifies all clients of events
    [ClientRpc]
    public void RpcOnWeaponFired(Vector3 targetPosition, Vector3 aimDirection)
    {
        // All clients play visual/audio effects
        PlayMuzzleFlash();
        PlayFireSound();
        CreateShellCasing();
        
        // Apply screen shake for weapon owner
        if (hasAuthority)
        {
            ApplyRecoilEffect();
            TriggerHapticFeedback();
        }
    }
    
    [ClientRpc]
    public void RpcOnWeaponModeChanged(int newMode)
    {
        // All clients update UI and visual state
        UpdateWeaponVisuals((WeaponState)newMode);
        UpdateUI();
        
        // Play mode switch sound
        PlayModeChangeSound();
    }
    
    [ClientRpc]
    public void RpcOnReloadComplete()
    {
        // All clients see reload completion
        PlayReloadCompleteSound();
        UpdateAmmoUI();
        
        // Reset weapon to ready state
        weaponState = WeaponState.Ready;
    }
    
    [ClientRpc]
    public void RpcApplyDamage(uint targetNetId, float damageAmount, Vector3 hitPoint)
    {
        // Find target and apply damage effects
        if (NetworkIdentity.spawned.TryGetValue(targetNetId, out var target))
        {
            var healthComponent = target.GetComponent<NetworkedHealth>();
            if (healthComponent != null)
            {
                healthComponent.ApplyDamageEffect(damageAmount, hitPoint);
            }
        }
    }
}
```

### 3. TargetRpc Pattern (Server to Specific Client)
```csharp
public class NetworkedWeapon : NetworkBehaviour
{
    // Server sends message to specific client
    [TargetRpc]
    public void TargetOnWeaponJammed(NetworkConnection target)
    {
        // Only the weapon owner sees jam notification
        ShowWeaponJamUI();
        PlayJamSound();
        TriggerJamHapticFeedback();
    }
    
    [TargetRpc]
    public void TargetOnLowAmmoWarning(NetworkConnection target)
    {
        // Only weapon owner gets low ammo warning
        StartLowAmmoUIFlash();
        PlayLowAmmoSound();
    }
    
    [TargetRpc]
    public void TargetOnWeaponOverheated(NetworkConnection target, float cooldownTime)
    {
        // Only weapon owner sees overheat effects
        StartOverheatUIEffect(cooldownTime);
        StartOverheatCooldownTimer(cooldownTime);
    }
    
    // Example usage in command
    [Command]
    public void CmdAttemptFire()
    {
        if (IsWeaponJammed())
        {
            TargetOnWeaponJammed(connectionToClient);
            return;
        }
        
        if (currentAmmo <= 3) // Low ammo threshold
        {
            TargetOnLowAmmoWarning(connectionToClient);
        }
        
        // Continue with fire logic...
    }
}
```

## Advanced Networking Patterns

### 1. Client Prediction with Server Reconciliation
```csharp
public class PredictiveWeapon : NetworkBehaviour
{
    [Header("Prediction Settings")]
    public bool enableClientPrediction = true;
    public float reconciliationThreshold = 0.1f;
    
    // Client-side state for prediction
    private struct WeaponState
    {
        public float ammo;
        public Vector3 position;
        public Quaternion rotation;
        public float timestamp;
    }
    
    private Queue<WeaponState> _clientStateHistory = new Queue<WeaponState>();
    private Queue<WeaponState> _serverStateHistory = new Queue<WeaponState>();
    
    // Client predicts action immediately
    public void PredictiveFireWeapon(Vector3 target)
    {
        if (!hasAuthority) return;
        
        if (enableClientPrediction)
        {
            // Immediate client-side prediction
            PerformClientPrediction(target);
            
            // Store state for reconciliation
            StoreClientState();
        }
        
        // Send command to server
        CmdFireWeapon(target);
    }
    
    private void PerformClientPrediction(Vector3 target)
    {
        // Apply immediate visual feedback
        PlayMuzzleFlash();
        ApplyRecoil();
        
        // Update local ammo count
        currentAmmo--;
        
        // Create local projectile trail
        CreatePredictiveProjectile(target);
    }
    
    [Command]
    public void CmdFireWeapon(Vector3 target)
    {
        // Server validates and performs authoritative action
        if (!CanFire()) return;
        
        PerformAuthoritativefire(target);
        
        // Send authoritative result back
        TargetReconcileWeaponState(connectionToClient, 
            GetCurrentWeaponState(), Time.time);
    }
    
    [TargetRpc]
    public void TargetReconcileWeaponState(NetworkConnection conn, 
        WeaponState authoritativeState, float serverTime)
    {
        if (!hasAuthority) return;
        
        // Find matching client state
        var clientState = FindClientStateAtTime(serverTime);
        
        // Check if reconciliation is needed
        if (ShouldReconcile(clientState, authoritativeState))
        {
            ApplyReconciliation(authoritativeState);
        }
    }
    
    private bool ShouldReconcile(WeaponState client, WeaponState server)
    {
        return Vector3.Distance(client.position, server.position) > reconciliationThreshold
            || Mathf.Abs(client.ammo - server.ammo) > 0.5f;
    }
}
```

### 2. Network Object Pooling
```csharp
public class NetworkedProjectilePool : NetworkBehaviour
{
    [Header("Pool Configuration")]
    public GameObject projectilePrefab;
    public int poolSize = 50;
    public float maxLifetime = 10f;
    
    private Queue<GameObject> _availableProjectiles = new Queue<GameObject>();
    private Dictionary<uint, float> _activeProjectiles = new Dictionary<uint, float>();
    
    public override void OnStartServer()
    {
        InitializePool();
    }
    
    private void InitializePool()
    {
        for (int i = 0; i < poolSize; i++)
        {
            var projectile = Instantiate(projectilePrefab);
            var netId = projectile.GetComponent<NetworkIdentity>();
            
            // Don't spawn immediately - keep in pool
            projectile.SetActive(false);
            _availableProjectiles.Enqueue(projectile);
        }
    }
    
    [Server]
    public GameObject GetProjectile(Vector3 position, Quaternion rotation)
    {
        GameObject projectile;
        
        if (_availableProjectiles.Count > 0)
        {
            projectile = _availableProjectiles.Dequeue();
        }
        else
        {
            // Pool exhausted - create new projectile
            projectile = Instantiate(projectilePrefab);
        }
        
        // Configure projectile
        projectile.transform.position = position;
        projectile.transform.rotation = rotation;
        projectile.SetActive(true);
        
        // Spawn on network
        NetworkServer.Spawn(projectile);
        
        // Track for cleanup
        var netId = projectile.GetComponent<NetworkIdentity>().netId;
        _activeProjectiles[netId] = Time.time;
        
        return projectile;
    }
    
    [Server]
    public void ReturnProjectile(GameObject projectile)
    {
        var netId = projectile.GetComponent<NetworkIdentity>();
        
        // Remove from active tracking
        _activeProjectiles.Remove(netId.netId);
        
        // Despawn from network
        NetworkServer.UnSpawn(projectile);
        
        // Reset and return to pool
        projectile.SetActive(false);
        projectile.transform.position = Vector3.zero;
        _availableProjectiles.Enqueue(projectile);
    }
    
    private void Update()
    {
        if (!isServer) return;
        
        // Clean up old projectiles
        var toRemove = new List<uint>();
        foreach (var kvp in _activeProjectiles)
        {
            if (Time.time - kvp.Value > maxLifetime)
            {
                toRemove.Add(kvp.Key);
            }
        }
        
        foreach (var netId in toRemove)
        {
            if (NetworkIdentity.spawned.TryGetValue(netId, out var projectile))
            {
                ReturnProjectile(projectile.gameObject);
            }
        }
    }
}
```

### 3. Custom Network Messages
```csharp
// Custom message structures
public struct WeaponFireMessage : NetworkMessage
{
    public uint weaponNetId;
    public Vector3 targetPosition;
    public Vector3 fireDirection;
    public float fireTime;
    public WeaponType weaponType;
}

public struct SpellCastMessage : NetworkMessage
{
    public uint casterNetId;
    public SpellType spellType;
    public Vector3 castPosition;
    public Vector3 targetPosition;
    public float manaConsumed;
    public SpellModifier[] modifiers;
}

public class ModNetworkManager : NetworkManager
{
    public override void OnStartServer()
    {
        base.OnStartServer();
        
        // Register custom message handlers
        NetworkServer.RegisterHandler<WeaponFireMessage>(OnWeaponFireMessage);
        NetworkServer.RegisterHandler<SpellCastMessage>(OnSpellCastMessage);
    }
    
    public override void OnStartClient()
    {
        base.OnStartClient();
        
        // Register client message handlers
        NetworkClient.RegisterHandler<WeaponFireMessage>(OnWeaponFireMessage);
        NetworkClient.RegisterHandler<SpellCastMessage>(OnSpellCastMessage);
    }
    
    private void OnWeaponFireMessage(NetworkConnection conn, WeaponFireMessage msg)
    {
        // Handle weapon fire message
        if (NetworkIdentity.spawned.TryGetValue(msg.weaponNetId, out var weaponId))
        {
            var weapon = weaponId.GetComponent<NetworkedWeapon>();
            weapon?.ProcessNetworkFire(msg);
        }
    }
    
    private void OnSpellCastMessage(NetworkConnection conn, SpellCastMessage msg)
    {
        // Handle spell cast message
        if (NetworkIdentity.spawned.TryGetValue(msg.casterNetId, out var casterId))
        {
            var caster = casterId.GetComponent<NetworkedSpellCaster>();
            caster?.ProcessNetworkSpellCast(msg);
        }
    }
}
```

## VR-Specific Networking Considerations

### 1. Hand Tracking Synchronization
```csharp
public class NetworkedVRHands : NetworkBehaviour
{
    [Header("VR Hand Tracking")]
    public Transform leftHandTransform;
    public Transform rightHandTransform;
    
    [Header("Sync Settings")]
    public float positionSyncRate = 20f;
    public float rotationSyncRate = 20f;
    
    // Networked hand data
    [SyncVar]
    private Vector3 _networkLeftHandPos;
    [SyncVar]
    private Quaternion _networkLeftHandRot;
    [SyncVar]
    private Vector3 _networkRightHandPos;
    [SyncVar]
    private Quaternion _networkRightHandRot;
    
    // Hand poses for gestures
    [SyncVar(hook = nameof(OnLeftHandPoseChanged))]
    public HandPose leftHandPose;
    [SyncVar(hook = nameof(OnRightHandPoseChanged))]
    public HandPose rightHandPose;
    
    private float _lastSyncTime;
    
    private void Update()
    {
        if (hasAuthority)
        {
            // Send hand position updates at controlled rate
            if (Time.time - _lastSyncTime >= 1f / positionSyncRate)
            {
                UpdateHandPositions();
                _lastSyncTime = Time.time;
            }
        }
        else
        {
            // Interpolate remote player hands
            InterpolateRemoteHands();
        }
    }
    
    private void UpdateHandPositions()
    {
        // Get current VR hand positions
        _networkLeftHandPos = leftHandTransform.position;
        _networkLeftHandRot = leftHandTransform.rotation;
        _networkRightHandPos = rightHandTransform.position;
        _networkRightHandRot = rightHandTransform.rotation;
        
        // Send gesture updates when they change
        var currentLeftPose = GetCurrentHandPose(leftHandTransform);
        var currentRightPose = GetCurrentHandPose(rightHandTransform);
        
        if (currentLeftPose != leftHandPose)
        {
            CmdUpdateHandPose(true, currentLeftPose);
        }
        
        if (currentRightPose != rightHandPose)
        {
            CmdUpdateHandPose(false, currentRightPose);
        }
    }
    
    [Command]
    public void CmdUpdateHandPose(bool isLeftHand, HandPose newPose)
    {
        if (isLeftHand)
            leftHandPose = newPose;
        else
            rightHandPose = newPose;
    }
    
    private void OnLeftHandPoseChanged(HandPose oldPose, HandPose newPose)
    {
        if (!hasAuthority)
        {
            ApplyHandPose(leftHandTransform, newPose);
        }
    }
    
    private void OnRightHandPoseChanged(HandPose oldPose, HandPose newPose)
    {
        if (!hasAuthority)
        {
            ApplyHandPose(rightHandTransform, newPose);
        }
    }
}
```

### 2. VR Interaction Networking
```csharp
public class NetworkedVRInteraction : NetworkBehaviour
{
    [Header("VR Interaction")]
    public XRGrabInteractable grabInteractable;
    public LayerMask networkSyncLayers = -1;
    
    [SyncVar(hook = nameof(OnGrabStateChanged))]
    public bool isGrabbed = false;
    
    [SyncVar]
    public uint grabbingPlayerNetId;
    
    private Vector3 _networkPosition;
    private Quaternion _networkRotation;
    private Vector3 _networkVelocity;
    private Vector3 _networkAngularVelocity;
    
    protected override void OnEnable()
    {
        base.OnEnable();
        
        if (grabInteractable != null)
        {
            grabInteractable.selectEntered.AddListener(OnGrabbed);
            grabInteractable.selectExited.AddListener(OnReleased);
        }
    }
    
    private void OnGrabbed(SelectEnterEventArgs args)
    {
        if (!hasAuthority) return;
        
        // Notify network of grab
        CmdOnGrabbed();
    }
    
    private void OnReleased(SelectExitEventArgs args)
    {
        if (!hasAuthority) return;
        
        // Get release velocity for throwing
        var rb = GetComponent<Rigidbody>();
        var releaseVelocity = rb ? rb.velocity : Vector3.zero;
        var releaseAngularVel = rb ? rb.angularVelocity : Vector3.zero;
        
        // Notify network of release
        CmdOnReleased(releaseVelocity, releaseAngularVel);
    }
    
    [Command]
    public void CmdOnGrabbed()
    {
        isGrabbed = true;
        grabbingPlayerNetId = connectionToClient.identity.netId;
        
        // Transfer authority to grabbing player
        NetworkIdentity.AssignClientAuthority(connectionToClient);
    }
    
    [Command]
    public void CmdOnReleased(Vector3 releaseVelocity, Vector3 releaseAngularVelocity)
    {
        isGrabbed = false;
        grabbingPlayerNetId = 0;
        
        // Apply release physics
        var rb = GetComponent<Rigidbody>();
        if (rb != null)
        {
            rb.velocity = releaseVelocity;
            rb.angularVelocity = releaseAngularVelocity;
        }
        
        // Return authority to server
        NetworkIdentity.RemoveClientAuthority();
    }
    
    private void OnGrabStateChanged(bool oldGrabbed, bool newGrabbed)
    {
        // Update visual state for all clients
        UpdateGrabVisuals(newGrabbed);
        
        // Handle physics state
        var rb = GetComponent<Rigidbody>();
        if (rb != null)
        {
            rb.isKinematic = newGrabbed && !hasAuthority;
        }
    }
}
```

## Performance Optimization for Multiplayer

### 1. Network Update Optimization
```csharp
public class OptimizedNetworkWeapon : NetworkBehaviour
{
    [Header("Network Optimization")]
    public float updateRate = 10f; // Updates per second
    public float distanceOptimization = 50f; // Reduce updates at distance
    public bool useInterestManagement = true;
    
    private float _lastUpdateTime;
    private Vector3 _lastPosition;
    private Quaternion _lastRotation;
    
    private void Update()
    {
        if (!hasAuthority) return;
        
        // Determine update rate based on activity and distance
        float actualUpdateRate = CalculateOptimalUpdateRate();
        
        if (Time.time - _lastUpdateTime >= 1f / actualUpdateRate)
        {
            CheckForNetworkUpdates();
            _lastUpdateTime = Time.time;
        }
    }
    
    private float CalculateOptimalUpdateRate()
    {
        float baseRate = updateRate;
        
        // Reduce rate if object is far from other players
        if (useInterestManagement)
        {
            float minDistance = GetDistanceToNearestPlayer();
            if (minDistance > distanceOptimization)
            {
                baseRate *= 0.5f; // Half rate for distant objects
            }
        }
        
        // Increase rate if object is moving quickly
        var rb = GetComponent<Rigidbody>();
        if (rb != null && rb.velocity.magnitude > 10f)
        {
            baseRate *= 1.5f; // Faster updates for fast-moving objects
        }
        
        return Mathf.Clamp(baseRate, 2f, 30f); // Keep within reasonable bounds
    }
    
    private void CheckForNetworkUpdates()
    {
        bool positionChanged = Vector3.Distance(transform.position, _lastPosition) > 0.01f;
        bool rotationChanged = Quaternion.Angle(transform.rotation, _lastRotation) > 1f;
        
        if (positionChanged || rotationChanged)
        {
            CmdUpdateTransform(transform.position, transform.rotation);
            
            _lastPosition = transform.position;
            _lastRotation = transform.rotation;
        }
    }
    
    [Command]
    public void CmdUpdateTransform(Vector3 position, Quaternion rotation)
    {
        // Validate movement to prevent cheating
        if (!IsValidMovement(position))
        {
            Debug.LogWarning($"Invalid movement detected from {connectionToClient}");
            return;
        }
        
        // Update authoritative position
        transform.position = position;
        transform.rotation = rotation;
        
        // Broadcast to other clients
        RpcUpdateTransform(position, rotation);
    }
    
    [ClientRpc(includeOwner = false)]
    public void RpcUpdateTransform(Vector3 position, Quaternion rotation)
    {
        // Smooth interpolation for remote objects
        StartCoroutine(InterpolateToPosition(position, rotation));
    }
}
```

### 2. Bandwidth Management
```csharp
public class NetworkBandwidthManager : NetworkBehaviour
{
    [Header("Bandwidth Settings")]
    public int maxUpdatesPerSecond = 20;
    public int maxConcurrentMessages = 5;
    
    private Queue<System.Action> _messageQueue = new Queue<System.Action>();
    private float _lastMessageTime;
    private int _messagesThisSecond;
    
    public void QueueNetworkMessage(System.Action message)
    {
        _messageQueue.Enqueue(message);
        ProcessMessageQueue();
    }
    
    private void ProcessMessageQueue()
    {
        float currentTime = Time.time;
        
        // Reset counter every second
        if (currentTime - _lastMessageTime >= 1f)
        {
            _messagesThisSecond = 0;
            _lastMessageTime = currentTime;
        }
        
        // Process messages within bandwidth limits
        while (_messageQueue.Count > 0 && _messagesThisSecond < maxUpdatesPerSecond)
        {
            var message = _messageQueue.Dequeue();
            message.Invoke();
            _messagesThisSecond++;
        }
    }
    
    // Usage example
    public void SendWeaponUpdate()
    {
        QueueNetworkMessage(() => {
            CmdUpdateWeaponState(currentAmmo, weaponState);
        });
    }
}
```

## Debugging and Testing Multiplayer

### Network Debug Tools
```csharp
public class NetworkDebugger : NetworkBehaviour
{
    [Header("Debug Settings")]
    public bool showNetworkInfo = true;
    public bool logNetworkEvents = true;
    public KeyCode debugToggleKey = KeyCode.F12;
    
    private void Update()
    {
        if (Input.GetKeyDown(debugToggleKey))
        {
            showNetworkInfo = !showNetworkInfo;
        }
    }
    
    private void OnGUI()
    {
        if (!showNetworkInfo) return;
        
        GUILayout.BeginArea(new Rect(10, 10, 300, 200));
        GUILayout.BeginVertical("box");
        
        GUILayout.Label($"Network Mode: {GetNetworkMode()}");
        GUILayout.Label($"Is Server: {isServer}");
        GUILayout.Label($"Is Client: {isClient}");
        GUILayout.Label($"Has Authority: {hasAuthority}");
        GUILayout.Label($"Net ID: {netId}");
        GUILayout.Label($"Connection Count: {NetworkServer.connections.Count}");
        GUILayout.Label($"RTT: {NetworkTime.rtt * 1000:F0}ms");
        
        GUILayout.EndVertical();
        GUILayout.EndArea();
    }
    
    private string GetNetworkMode()
    {
        if (NetworkServer.active && NetworkClient.active)
            return "Host";
        else if (NetworkServer.active)
            return "Server";
        else if (NetworkClient.active)
            return "Client";
        else
            return "Offline";
    }
    
    // Network event logging
    public override void OnStartServer()
    {
        if (logNetworkEvents)
            Debug.Log($"[Network] Server started for {gameObject.name}");
    }
    
    public override void OnStartClient()
    {
        if (logNetworkEvents)
            Debug.Log($"[Network] Client started for {gameObject.name}");
    }
    
    public override void OnStartAuthority()
    {
        if (logNetworkEvents)
            Debug.Log($"[Network] Authority gained for {gameObject.name}");
    }
    
    public override void OnStopAuthority()
    {
        if (logNetworkEvents)
            Debug.Log($"[Network] Authority lost for {gameObject.name}");
    }
}
```
    
    void OnWeaponStateChanged(WeaponState oldState, WeaponState newState)
    {
        // Handle state changes on all clients
        UpdateWeaponVisuals(newState);
    }
}
```

## Synchronization Best Practices
- Sync only essential data to reduce bandwidth
- Use SyncVars for infrequent updates
- Use RPCs for events and actions
- Implement client-side prediction for responsive gameplay

## Authority Management
- Give authority to the player who owns the object
- Transfer authority when objects change hands
- Handle authority conflicts gracefully
- Validate all actions on the server

## Cross-Platform Networking
- Test networking between PC and Quest clients
- Handle different input methods (mouse/keyboard vs VR controllers)
- Ensure consistent physics simulation across platforms
- Account for different network conditions and latency

## Error Handling
```csharp
public class NetworkErrorHandler : NetworkBehaviour
{
    public override void OnStartServer()
    {
        NetworkManager.singleton.onServerError += OnServerError;
    }
    
    public override void OnStartClient()
    {
        NetworkManager.singleton.onClientError += OnClientError;
    }
    
    void OnServerError(Exception exception)
    {
        Debug.LogError($"Server error: {exception.Message}");
        // Handle server-side errors
    }
    
    void OnClientError(Exception exception)
    {
        Debug.LogError($"Client error: {exception.Message}");
        // Handle client-side errors
        // Possibly attempt reconnection
    }
}
```

## Performance Considerations
- Limit network update frequency to necessary rates
- Use compression for large data transfers
- Batch network messages when possible
- Monitor bandwidth usage and optimize accordingly
