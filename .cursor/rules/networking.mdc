# Networking with Mirror

## Multiplayer Architecture
- Use Mirror networking components for all multiplayer features
- Implement proper client-server architecture
- Handle authority and ownership correctly
- Design for both local and remote players

## NetworkBehaviour Implementation
```csharp
using Mirror;

public class NetworkedWeapon : NetworkBehaviour
{
    [SyncVar(hook = nameof(OnWeaponStateChanged))]
    public WeaponState currentState;
    
    [SyncVar]
    public float damage = 10f;
    
    // Client-side prediction for responsive gameplay
    [Client]
    public void RequestAttack()
    {
        if (!hasAuthority) return;
        
        // Immediate visual feedback
        PlayAttackAnimation();
        
        // Send to server for validation
        CmdPerformAttack();
    }
    
    [Command]
    void CmdPerformAttack()
    {
        // Server validates and applies damage
        if (CanAttack())
        {
            PerformAttack();
            RpcPlayAttackEffect();
        }
    }
    
    [ClientRpc]
    void RpcPlayAttackEffect()
    {
        // Play effects on all clients
        PlayAttackEffects();
    }
    
    void OnWeaponStateChanged(WeaponState oldState, WeaponState newState)
    {
        // Handle state changes on all clients
        UpdateWeaponVisuals(newState);
    }
}
```

## Synchronization Best Practices
- Sync only essential data to reduce bandwidth
- Use SyncVars for infrequent updates
- Use RPCs for events and actions
- Implement client-side prediction for responsive gameplay

## Authority Management
- Give authority to the player who owns the object
- Transfer authority when objects change hands
- Handle authority conflicts gracefully
- Validate all actions on the server

## Cross-Platform Networking
- Test networking between PC and Quest clients
- Handle different input methods (mouse/keyboard vs VR controllers)
- Ensure consistent physics simulation across platforms
- Account for different network conditions and latency

## Error Handling
```csharp
public class NetworkErrorHandler : NetworkBehaviour
{
    public override void OnStartServer()
    {
        NetworkManager.singleton.onServerError += OnServerError;
    }
    
    public override void OnStartClient()
    {
        NetworkManager.singleton.onClientError += OnClientError;
    }
    
    void OnServerError(Exception exception)
    {
        Debug.LogError($"Server error: {exception.Message}");
        // Handle server-side errors
    }
    
    void OnClientError(Exception exception)
    {
        Debug.LogError($"Client error: {exception.Message}");
        // Handle client-side errors
        // Possibly attempt reconnection
    }
}
```

## Performance Considerations
- Limit network update frequency to necessary rates
- Use compression for large data transfers
- Batch network messages when possible
- Monitor bandwidth usage and optimize accordingly
